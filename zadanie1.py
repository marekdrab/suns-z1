# -*- coding: utf-8 -*-
"""zadanie1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Qm5u9QgosSGgxwYIdVoVf-81Szi-ZS-
"""

import pandas as pd
import keras
import plotly.graph_objects as go
import numpy as np
import matplotlib.pyplot as plt
import seaborn
import plotly.express as px

from google.colab import drive
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense
from tensorflow.keras.optimizers import Adam
from plotly.subplots import make_subplots
from sklearn.utils import class_weight
from sklearn.utils import compute_class_weight
from sklearn.metrics import confusion_matrix

drive.mount('/content/drive')
data_path = '/content/drive/MyDrive/SUNS/zadanie1/'
train_data_path = data_path + 'train.csv'
test_data_path = data_path + 'test.csv'

df = pd.read_csv(train_data_path)

dft =  pd.read_csv(test_data_path)

df.dropna(inplace=True)

# https://stackoverflow.com/questions/25146121/extracting-just-month-and-year-separately-from-pandas-datetime-column
df['D_release_date'] =  pd.DatetimeIndex(df['D_release_date']).year
dft['D_release_date'] =  pd.DatetimeIndex(dft['D_release_date']).year


df['D_owners'] = pd.Series(df['D_owners'], dtype="string")
tmp = df['D_owners'].str.split(" .. ", expand=True)[1].str.replace(',', '')
tmp = tmp.astype(int)
df['owners'] = tmp.copy()

dft['D_owners'] = pd.Series(dft['D_owners'], dtype="string")
tmp2 = dft['D_owners'].str.split(" .. ", expand=True)[1].str.replace(',', '')
tmp2 = tmp2.astype(int)
dft['owners'] = tmp2.copy()

df.head(5)

#https://www.geeksforgeeks.org/count-all-rows-or-those-that-satisfy-some-condition-in-pandas-dataframe/
details = df.apply(lambda x : True
                   if (x['self_published'] == True) & (x['is_free'] == True) else False, axis = 1)
  
# Count number of True in the series
self_published_is_free = len(details[details == True].index)

details = df.apply(lambda x : True
                   if (x['self_published'] == True) & (x['is_free'] == False) else False, axis = 1)
  
# Count number of True in the series
self_published_not_free = len(details[details == True].index)

details = df.apply(lambda x : True
                   if (x['self_published'] == False) & (x['is_free'] == True) else False, axis = 1)
  
# Count number of True in the series
not_self_published_is_free = len(details[details == True].index)

details = df.apply(lambda x : True
                   if (x['self_published'] == False) & (x['is_free'] == False) else False, axis = 1)
  
# Count number of True in the series
not_self_published_not_free = len(details[details == True].index)

#https://www.geeksforgeeks.org/bar-plot-in-matplotlib/
data = {'self_published_is_free':self_published_is_free, 'self_published_not_free':self_published_not_free, 'not_self_published_is_free':not_self_published_is_free,
        'not_self_published_not_free':not_self_published_not_free}

keys = list(data.keys())
values = list(data.values())
  
fig = plt.figure(figsize = (10, 5))
 
# creating the bar plot
plt.bar(keys, values, color ='maroon',
        width = 0.4)
 
plt.ylabel("Count")
plt.show()

owners_self_published = df[df['self_published'] == True]['owners']
owners_not_self_published = df[df['self_published'] == False]['owners']
  
owners_self_published.plot()
owners_not_self_published.plot()

x_train = df.drop(['D_owners','D_tags','VYMAZAT_price', 'D_appid', 'D_name', 'positive', 'negative', 'D_reviews','D_genre','is_free','ccu','D_developer','D_publisher','Addictive','Beautiful','Masterpiece','Well-Written', 'Lore-Rich','Epic','Emotional','Cult Classic','Competitive' ], axis=1)
y_train = df['is_free']

x_test = dft.drop(['D_owners','D_tags','VYMAZAT_price', 'D_appid', 'D_name', 'positive', 'negative', 'D_reviews','D_genre','is_free','ccu','D_developer','D_publisher','Addictive','Beautiful','Masterpiece','Well-Written', 'Lore-Rich','Epic','Emotional','Cult Classic','Competitive' ], axis=1)
y_test = dft['is_free']

x_train

x_train.std()

x_test.std()

fig = px.pie(x_train['Funny'].replace({0: 'Not Funny', 1: 'Funny'}), names='Funny')
fig.show()

scaler = MinMaxScaler()
x_train = pd.DataFrame(scaler.fit_transform(x_train), columns = x_train.columns, index=x_train.index)

x_test = pd.DataFrame(scaler.fit_transform(x_test), columns = x_test.columns, index=x_test.index)

x_train

x_train.hist(figsize=(20,20))

plt.figure(figsize=(20, 20))
conv = pd.DataFrame.cov(pd.DataFrame(x_train))
seaborn.heatmap(conv, annot=False, fmt='2g')
plt.show()

x_train.std()

x_test.std()

# https://datascience.stackexchange.com/questions/13490/how-to-set-class-weights-for-imbalanced-classes-in-keras
class_weights = class_weight.compute_class_weight(
                                        class_weight = "balanced",
                                        classes = np.unique(y_train),
                                        y = y_train                                                    
                                    )
class_weights = dict(zip(np.unique(y_train), class_weights))
class_weights

model = Sequential()

model.add(Dense(256, input_shape=(x_train.shape[1],),activation='relu'))
model.add(Dense(128, activation='softmax'))
model.add(Dense(512, activation='tanh'))
model.add(Dense(128, activation='tanh'))
model.add(Dense(64, activation='softmax'))
model.add(Dense(1,activation='sigmoid'))

optimizer = Adam(learning_rate=0.001)
early_stopping = keras.callbacks.EarlyStopping(monitor='val_loss', patience=30)

model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=['accuracy'])

#training = model.fit(x_train, y_train, validation_split=0.05, epochs=200, batch_size=64, verbose=1, callbacks=[early_stopping])

training = model.fit(x_train, y_train, validation_split=0.1, epochs=200, batch_size=64, verbose=1,  class_weight=class_weights)

fig_training = make_subplots(rows=1, cols=2, subplot_titles=['Accuracy', 'Loss'])

training_history = pd.DataFrame.from_dict(training.history)
fig_training.add_trace(go.Scatter(y=training_history['val_loss'], name='val_loss', mode='lines'), row=1, col=2)
fig_training.add_trace(go.Scatter(y=training_history['accuracy'], name='accuracy', mode='lines'), row=1, col=1)
fig_training.add_trace(go.Scatter(y=training_history['loss'], name='loss', mode='lines'), row=1, col=2)
fig_training.add_trace(go.Scatter(y=training_history['val_accuracy'], name='val_accuracy', mode='lines'), row=1, col=1)
fig_training.show()

y_train_prediction = np.round(model.predict(x_train))
cm_df = pd.DataFrame(confusion_matrix(y_train, y_train_prediction))

fig_cm = go.Figure(data=go.Heatmap(
        z=cm_df,
        x=['0', '1'],
        y=['0', '1']
    ))
fig_cm.update_xaxes(type='category')
fig_cm.update_yaxes(type='category')
fig_cm.show()

y_test_prediction = np.round(model.predict(x_test))
cm_df = pd.DataFrame(confusion_matrix(y_test, y_test_prediction))

fig_cm = go.Figure(data=go.Heatmap(
        z=cm_df,
        x=['0', '1'],
        y=['0', '1']
    ))
fig_cm.update_xaxes(type='category')
fig_cm.update_yaxes(type='category')
fig_cm.show()